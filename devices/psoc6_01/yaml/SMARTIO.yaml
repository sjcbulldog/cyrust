---
block/PRT:
  description: Programmable IO port registers
  items:
    - name: CTL
      description: Control register
      byte_offset: 0
      fieldset: CTL
    - name: SYNC_CTL
      description: Synchronization control register
      byte_offset: 16
      fieldset: SYNC_CTL
    - name: LUT_SEL
      description: LUT component input selection
      array:
        len: 8
        stride: 4
      byte_offset: 32
      fieldset: LUT_SEL
    - name: LUT_CTL
      description: LUT component control register
      array:
        len: 8
        stride: 4
      byte_offset: 64
      fieldset: LUT_CTL
    - name: DU_SEL
      description: Data unit component input selection
      byte_offset: 192
      fieldset: DU_SEL
    - name: DU_CTL
      description: Data unit component control register
      byte_offset: 196
      fieldset: DU_CTL
    - name: DATA
      description: Data register
      byte_offset: 240
      fieldset: DATA
block/SMARTIO:
  description: Programmable IO configuration
  items:
    - name: PRT
      description: Programmable IO port registers
      array:
        len: 10
        stride: 256
      byte_offset: 0
      block: PRT
fieldset/CTL:
  description: Control register
  fields:
    - name: BYPASS
      description: "Bypass of the programmable IO, one bit for each IO pin: BYPASS[i] is for IO pin i. When ENABLED is '1', this field is used. When ENABLED is '0', this field is NOT used and SMARTIO fabric is always bypassed. '0': No bypass (programmable SMARTIO fabric is exposed). '1': Bypass (programmable SMARTIOIO fabric is hidden)."
      bit_offset: 0
      bit_size: 8
    - name: CLOCK_SRC
      description: "Clock ('clk_fabric') and reset ('rst_fabric_n') source selection: '0': io_data_in[0]/'1'. ... '7': io_data_in[7]/'1'. '8': chip_data[0]/'1'. ... '15': chip_data[7]/'1'. '16': clk_smartio/rst_sys_act_n. Used for both Active functionality synchronous logic on 'clk_smartio'. This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_smartio_pos_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. '17': clk_smartio/rst_sys_dpslp_n. Used for both DeepSleep functionality synchronous logic on 'clk_smartio' (note that 'clk_smartio' is NOT available in DeepSleep and Hibernate power modes). This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_smartio_pos_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. '18': Same as '17'. Note that the M0S8 SMARTIO version used the Hibernate reset for this value, but the MXS40 SMARTIO version does not support Hibernate functionality. '19': clk_lf/rst_lf_dpslp_n (note that 'clk_lf' is available in DeepSleep power mode). This selection is intended for synchronous operation on'clk_lf'. Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to other 'clk_lf' clocked elements. '20'-'30': Clock source is constant '0'. Any of these clock sources should be selected when the IP is disabled to ensure low power consumption. '31': asynchronous mode/'1'. Select this when clockless operation is configured. NOTE: Two positive edges of the selected clock are required for the block to be enabled (to deactivate reset). In asynchronous (clockless) mode clk_sys is used to enable the block, but is not available for clocking."
      bit_offset: 8
      bit_size: 5
    - name: HLD_OVR
      description: "IO cell hold override functionality. In DeepSleep power mode, the HSIOM holds the IO cell output and output enable signals if Active functionality is connected to the IO pads. This is undesirable if the SMARTIO is supposed to deliver DeepSleep output functionality on these IO pads. This field is used to control the hold override functionality from the SMARTIO: '0': The HSIOM controls the IO cell hold override functionality ('hsiom_hld_ovr'). '1': The SMARTIO controls the IO cel hold override functionality: - In bypass mode (ENABLED is '0' or BYPASS[i] is '1'), the HSIOM control is used. - In NON bypass mode (ENABLED is '1' and BYPASS[i] is '0'), the SMARTIO sets hold override to 'pwr_hld_ovr_hib' to enable SMARTIO functionality in DeepSleep power mode (but disables it in Hibernate or Stop power mode)."
      bit_offset: 24
      bit_size: 1
    - name: PIPELINE_EN
      description: "Enable for pipeline register: '0': Disabled (register is bypassed). '1': Enabled."
      bit_offset: 25
      bit_size: 1
    - name: ENABLED
      description: "Enable for programmable IO. Should only be set to '1' when the programmable IO is completely configured: '0': Disabled (signals are bypassed; behavior as if BYPASS is 0xFF). When disabled, the fabric (data unit and LUTs) reset is activated. If the IP is disabled: - The PIPELINE_EN register field should be set to '1', to ensure low power consumption by preventing combinatorial loops. - The CLOCK_SRC register field should be set to '20'-'30' (clock is constant '0'), to ensure low power consumption. '1': Enabled. Once enabled, it takes 3 'clk_fabric' clock cycles till the fabric reset is de-activated and the fabric becomes fully functional. This ensures that the IO pins' input synchronizer states are flushed when the fabric is fully functional."
      bit_offset: 31
      bit_size: 1
fieldset/DATA:
  description: Data register
  fields:
    - name: DATA
      description: Data unit input data source.
      bit_offset: 0
      bit_size: 8
fieldset/DU_CTL:
  description: Data unit component control register
  fields:
    - name: DU_SIZE
      description: "Size/width of the data unit data operands (in bits) is DU_SIZE+1. E.g., if DU_SIZE is 7, the width is 8 bits."
      bit_offset: 0
      bit_size: 3
    - name: DU_OPC
      description: "Data unit opcode specifies the data unit operation: '1': INCR '2': DECR '3': INCR_WRAP '4': DECR_WRAP '5': INCR_DECR '6': INCR_DECR_WRAP '7': ROR '8': SHR '9': AND_OR '10': SHR_MAJ3 '11': SHR_EQL. Otherwise: Undefined."
      bit_offset: 8
      bit_size: 4
fieldset/DU_SEL:
  description: Data unit component input selection
  fields:
    - name: DU_TR0_SEL
      description: "Data unit input signal 'tr0_in' source selection: '0': Constant '0'. '1': Constant '1'. '2': Data unit output. '10-3': LUT 7 - 0 outputs. Otherwise: Undefined."
      bit_offset: 0
      bit_size: 4
    - name: DU_TR1_SEL
      description: "Data unit input signal 'tr1_in' source selection. Encoding is the same as for DU_TR0_SEL."
      bit_offset: 8
      bit_size: 4
    - name: DU_TR2_SEL
      description: "Data unit input signal 'tr2_in' source selection. Encoding is the same as for DU_TR0_SEL."
      bit_offset: 16
      bit_size: 4
    - name: DU_DATA0_SEL
      description: "Data unit input data 'data0_in' source selection: '0': Constant '0'. '1': chip_data[7:0]. '2': io_data_in[7:0]. '3': DATA.DATA MMIO register field."
      bit_offset: 24
      bit_size: 2
    - name: DU_DATA1_SEL
      description: "Data unit input data 'data1_in' source selection. Encoding is the same as for DU_DATA0_SEL."
      bit_offset: 28
      bit_size: 2
fieldset/LUT_CTL:
  description: LUT component control register
  fields:
    - name: LUT
      description: "LUT configuration. Depending on the LUT opcode LUT_OPC, the internal state lut_reg (captured in a flip-flop) and the LUT input signals tr0_in, tr1_in, tr2_in, the LUT configuration is used to determine the LUT output signal and the next sequential state (lut_reg)."
      bit_offset: 0
      bit_size: 8
    - name: LUT_OPC
      description: "LUT opcode specifies the LUT operation: '0': Combinatoral output, no feedback. tr_out = LUT[{tr2_in, tr1_in, tr0_in}]. '1': Combinatorial output, feedback. tr_out = LUT[{lut_reg, tr1_in, tr0_in}]. On clock: lut_reg <= tr_in2. '2': Sequential output, no feedback. temp = LUT[{tr2_in, tr1_in, tr0_in}]. tr_out = lut_reg. On clock: lut_reg <= temp. '3': Register with asynchronous set and reset. tr_out = lut_reg. enable = (tr2_in ^ LUT[4]) | LUT[5]. set = enable & (tr1_in ^ LUT[2]) & LUT[3]. clr = enable & (tr0_in ^ LUT[0]) & LUT[1]. Asynchronously (no clock required): lut_reg <= if (clr) '0' else if (set) '1'"
      bit_offset: 8
      bit_size: 2
fieldset/LUT_SEL:
  description: LUT component input selection
  fields:
    - name: LUT_TR0_SEL
      description: "LUT input signal 'tr0_in' source selection: '0': Data unit output. '1': LUT 1 output. '2': LUT 2 output. '3': LUT 3 output. '4': LUT 4 output. '5': LUT 5 output. '6': LUT 6 output. '7': LUT 7 output. '8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7). '9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7). '10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7). '11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7). '12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7). '13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7). '14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7). '15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7)."
      bit_offset: 0
      bit_size: 4
    - name: LUT_TR1_SEL
      description: "LUT input signal 'tr1_in' source selection: '0': LUT 0 output. '1': LUT 1 output. '2': LUT 2 output. '3': LUT 3 output. '4': LUT 4 output. '5': LUT 5 output. '6': LUT 6 output. '7': LUT 7 output. '8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7). '9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7). '10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7). '11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7). '12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7). '13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7). '14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7). '15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7)."
      bit_offset: 8
      bit_size: 4
    - name: LUT_TR2_SEL
      description: "LUT input signal 'tr2_in' source selection. Encoding is the same as for LUT_TR1_SEL."
      bit_offset: 16
      bit_size: 4
fieldset/SYNC_CTL:
  description: Synchronization control register
  fields:
    - name: IO_SYNC_EN
      description: "Synchronization of the IO pin input signals to 'clk_fabric', one bit for each IO pin: IO_SYNC_EN[i] is for IO pin i. '0': No synchronization. '1': Synchronization."
      bit_offset: 0
      bit_size: 8
    - name: CHIP_SYNC_EN
      description: "Synchronization of the chip input signals to 'clk_fabric', one bit for each input: CHIP_SYNC_EN[i] is for input i. '0': No synchronization. '1': Synchronization."
      bit_offset: 8
      bit_size: 8
